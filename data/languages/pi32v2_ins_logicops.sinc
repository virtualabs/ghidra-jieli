##################
#
# Logic Operations
#
##################

###########################################################################################
# OR
###########################################################################################

#
# rA |= rB
# => or rA, rB
#
:or regAl, regBl is group=0 & ins0712=0x32 & ins0303=0 & regAl & regBl
{
	regAl = regAl | regBl;
}

#
# rA = rB | rC
# => or rA, rB, rC
#
:or eregA, eregB, eregC is group=7 & ins0011=0x190 ; eregA & eregB & eregC & imm1619=0
{
    eregA = eregB | eregC;
}

###########################################################################################
# XOR
###########################################################################################

#
# rA ^= rB
# => xor rA, rB
#
:xor regAl, regBl is group=0 & ins0712=0x32 & ins0303=1 & regAl & regBl
{
	regAl = regAl ^ regBl;
}

#
# rA = rB ^ bitmask (12-bits)
#
:xor regA, eregA, #packedimm12 is group=7 & ins0411=0x15 & regA ; eregA & packedimm12
{
    regA = eregA ^ packedimm12;
}

#
# rA = rB ^ rC
#
:xor eregA, eregB, eregC is group=7 & ins0011=0x190 ; eregA & eregB & eregC & imm1619=1
{
    eregA = eregB ^ eregC;
}

###########################################################################################
# NOT (one's complement)
###########################################################################################

#
# rA = ~rB
# => not rA, rB
#
:not regAl, regBl is group=0 & ins0712=0x33 & ins0303=0 & regAl & regBl
{
	regAl = ~regBl;
}

###########################################################################################
# AND
###########################################################################################

#
# rA &= rB
# => and rA, rB
#
:and regAl, regBl is group=0 & ins0712=0x33 & ins0303=1 & regAl & regBl
{
	regAl = regAl & regBl;
}

#
# rA = rB & mask (10 bits)
# => and rA, rB, #mask
:and regA, eregA, #imm1625 is group=7 & ins0411=0x16 & regA ; imm1625 & imm2627=0 & eregA
{
    regA = eregA & imm1625;
}

#
# rA = rB & mask (32 bits)
# => and rA, rB, #mask
:and regA, eregA, #mask is group=7 & ins0411=0x16 & regA ; imm1622 & imm2325 & imm2627=1 & eregA
[
    mask = ( (0x80 | imm1622) << 24 ) >> imm2325;
]
{
    regA = eregA & mask;
}

#
# rA = rB & mask (24 bits)
# => and rA, rB, #mask
:and regA, eregA, #mask is group=7 & ins0411=0x16 & regA ; imm1622 & imm2325 & imm2627=2 & eregA
[
    mask = ( (0x80 | imm1622) << 16 ) >> imm2325;
]
{
    regA = eregA & mask;
}

#
# rA = rB & mask (16 bits)
# => and rA, rB, #mask
:and regA, eregA, #mask is group=7 & ins0411=0x16 & regA ; imm1622 & imm2325 & imm2627=3 & eregA
[
    mask = ( (0x80 | imm1622) << 8 ) >> imm2325;
]
{
    regA = eregA & mask;
}


#
# rA = rB & mask (10 bits inverted)
# => and rA, rB, #mask
:and regA, eregA, #mask is group=7 & ins0411=0x17 & regA ; imm1625 & imm2627=0 & eregA
[ mask = imm1625^0xffffffff;]
{
    regA = eregA & mask;
}

#
# rA = rB & mask (32 bits)
# => and rA, rB, #mask
:and regA, eregA, #mask is group=7 & ins0411=0x17 & regA ; imm1622 & imm2325 & imm2627=1 & eregA
[
    mask = (( (0x80 | imm1622) << 24 ) >> imm2325) ^ 0xffffffff;
]
{
    regA = eregA & mask;
}

#
# rA = rB & mask (24 bits)
# => and rA, rB, #mask
:and regA, eregA, #mask is group=7 & ins0411=0x17 & regA ; imm1622 & imm2325 & imm2627=2 & eregA
[
    mask = (( (0x80 | imm1622) << 16 ) >> imm2325) ^ 0xffffffff;
]
{
    regA = eregA & mask;
}

#
# rA = rB & mask (16 bits)
# => and rA, rB, #mask
:and regA, eregA, #mask is group=7 & ins0411=0x17 & regA ; imm1622 & imm2325 & imm2627=3 & eregA
[
    mask = (( (0x80 | imm1622) << 8 ) >> imm2325) ^ 0xffffffff;
]
{
    regA = eregA & mask;
}

#
# rA = rB & rC
# => and rA, rB, rC
#
:and eregA, eregB, eregC is group=7 & ins0011=0x190 ; eregA & eregB & eregC & imm1619=2
{
    eregA = eregB & eregC;
}

#
# rA = rB & not(rC)
#
:andnot eregA, eregB, eregC is group=7 & ins0011=0x190 ; eregA & eregB & eregC & imm1619=3
{
    eregA = eregB & ~(eregC);
}

# Insert bits from rB at specific position in rA (msbit to lsbit)
# rA <= insert(rB, pos:imm5, len:imm5) # special case
# insert regA, regB, pos, len
#
:insert regA, eregA, imm2327, imm1822 is group=7 & ins0411=0x1a & regA ; eregA & imm1617 & imm1822 & imm2327
{
    # Create a bitmask for source register
    smask = ((1 << imm1822) - 1) & 0xffffffff;

    # Create a bitmask for destination register
    dmask = (smask << imm2327) & 0xffffffff;

    # Copy register bits
    regA = (regA & ~dmask) | ((eregA & smask)<<imm2327);
}