##################
#
# Logic Operations
#
##################

###########################################################################################
# OR
###########################################################################################

#
# rA |= rB
# => or rA, rB
#
:or regAl, regBl is group=0 & ins0712=0x32 & ins0303=0 & regAl & regBl
{
	regAl = regAl | regBl;
}

###########################################################################################
# XOR
###########################################################################################

#
# rA ^= rB
# => xor rA, rB
#
:xor regAl, regBl is group=0 & ins0712=0x32 & ins0303=1 & regAl & regBl
{
	regAl = regAl ^ regBl;
}

#
# rA = rB ^ bitmask (12-bits)
#
:xor regA, eregA, #packedimm12 is group=7 & ins0411=0x15 & regA ; eregA & packedimm12
{
    regA = eregA ^ packedimm12;
}

#
# rA = rB ^ rC
#
:xor eregA, eregB, eregC is group=7 & ins0011=0x190 ; eregA & eregB & eregC & imm1619=1
{
    eregA = eregB ^ eregC;
}

###########################################################################################
# NOT (one's complement)
###########################################################################################

#
# rA = ~rB
# => not rA, rB
#
:not regAl, regBl is group=0 & ins0712=0x33 & ins0303=0 & regAl & regBl
{
	regAl = ~regBl;
}

###########################################################################################
# AND
###########################################################################################

#
# rA &= rB
# => and rA, rB
#
:and regAl, regBl is group=0 & ins0712=0x33 & ins0303=1 & regAl & regBl
{
	regAl = regAl & regBl;
}

#
# rA = rB & mask (10 bits)
# => and rA, rB, #mask
:and regA, eregA, #imm1625 is group=7 & ins0411=0x16 & regA ; imm1625 & imm2627=0 & eregA
{
    regA = eregA & imm1625;
}

#
# rA = rB & mask (32 bits)
# => and rA, rB, #mask
:and regA, eregA, #mask is group=7 & ins0411=0x16 & regA ; imm1622 & imm2325 & imm2627=1 & eregA
[
    mask = ( (0x80 | imm1622) << 24 ) >> imm2325;
]
{
    regA = eregA & mask;
}

#
# rA = rB & mask (24 bits)
# => and rA, rB, #mask
:and regA, eregA, #mask is group=7 & ins0411=0x16 & regA ; imm1622 & imm2325 & imm2627=2 & eregA
[
    mask = ( (0x80 | imm1622) << 16 ) >> imm2325;
]
{
    regA = eregA & mask;
}

#
# rA = rB & mask (16 bits)
# => and rA, rB, #mask
:and regA, eregA, #mask is group=7 & ins0411=0x16 & regA ; imm1622 & imm2325 & imm2627=3 & eregA
[
    mask = ( (0x80 | imm1622) << 8 ) >> imm2325;
]
{
    regA = eregA & mask;
}


#
# rA = rB & mask (10 bits inverted)
# => and rA, rB, #mask
:and regA, eregA, #mask is group=7 & ins0411=0x17 & regA ; imm1625 & imm2627=0 & eregA
[ mask = imm1625^0xffffffff;]
{
    regA = eregA & mask;
}

#
# rA = rB & mask (32 bits)
# => and rA, rB, #mask
:and regA, eregA, #mask is group=7 & ins0411=0x17 & regA ; imm1622 & imm2325 & imm2627=1 & eregA
[
    mask = (( (0x80 | imm1622) << 24 ) >> imm2325) ^ 0xffffffff;
]
{
    regA = eregA & mask;
}

#
# rA = rB & mask (24 bits)
# => and rA, rB, #mask
:and regA, eregA, #mask is group=7 & ins0411=0x17 & regA ; imm1622 & imm2325 & imm2627=2 & eregA
[
    mask = (( (0x80 | imm1622) << 16 ) >> imm2325) ^ 0xffffffff;
]
{
    regA = eregA & mask;
}

#
# rA = rB & mask (16 bits)
# => and rA, rB, #mask
:and regA, eregA, #mask is group=7 & ins0411=0x17 & regA ; imm1622 & imm2325 & imm2627=3 & eregA
[
    mask = (( (0x80 | imm1622) << 8 ) >> imm2325) ^ 0xffffffff;
]
{
    regA = eregA & mask;
}